//@version=5
indicator('Renko', max_bars_back=5000)
get_renko(box_size) =>
    var float base_price = input(title='Base price', defval=close)
    var float r_open = base_price - box_size
    var float r_close = close
    var int up_list = 0
    var int down_list = 0
    var int up_move = 0
    var int down_move = 0
    var int built_bricks_up = 0
    var int built_bricks_down = 0
    var int counter_up_series = 0
    var int counter_down_series = 0
    var int required_series_up = 0
    var int required_series_down = 0
    var int required_bricks_up = 0
    var int required_bricks_down = 0
    var bool b_up_list = false
    var bool b_down_list = false
    var bool b_up_move = false
    var bool b_down_move = false
    var bool in_the_range_up = false
    var bool in_the_range_down = false
    var int up_stop_index = 0
    var int down_stop_index = 0
    var int up_temporary_index = 0
    var int down_temporary_index = 0
    // creating lists
    if bar_index > 0
        if close > open
            down_move := 0
            if b_up_list
                up_move := int((close - base_price) / box_size)
                if up_move > up_list
                    up_list := up_move
                down_list := na
            else if b_down_list
                up_move := int((close - (base_price - down_list * box_size)) / box_size)
            else
                down_list := na
        else if close < open
            up_move := 0
            if b_down_list
                down_move := int((base_price - close) / box_size)
                if down_move > down_list
                    down_list := down_move
                up_list := na
            else if b_up_list
                down_move := int((base_price + up_list * box_size - close) / box_size)
            else
                down_list := na
                up_list := na
        if b_up_list and down_move >= 2
            base_price += (up_list - 1) * box_size
            b_up_list := false
            up_list := na
            b_down_list := true
            down_list := down_move - 1

        else if b_down_list and up_move >= 2
            base_price -= (down_list - 1) * box_size
            b_down_list := false
            down_list := na
            b_up_list := true
            up_list := up_move - 1

        if not b_up_list and not b_down_list
            up_move := int((close - base_price) / box_size)
            down_move := int((base_price - close) / box_size)
            if up_move > 0
                down_move := 0
                b_up_list := true
                b_up_move := true
                up_list := up_move
                down_list := na
            else if down_move > 0
                up_move := 0
                b_down_list := true
                b_down_move := true
                down_list := down_move
                up_list := na
    else
        up_list := na
        down_list := na
        r_close := na
    // creating open and close series
    if b_up_move
        for i = 0 to bar_index - up_stop_index - 1 by 1
            if not na(up_list[i]) and na(up_list[i + 1])
                counter_up_series += 1
                required_bricks_up := up_list[i]
                required_bricks_up
            if i == bar_index - up_stop_index - 1
                for j = i to 0 by 1
                    up_temporary_index := bar_index[j]
                    required_bricks_up := up_list[j]
                    if j == 0
                        break
                    if not na(up_list[j]) and na(up_list[j - 1])
                        up_temporary_index := bar_index[j - 1]
                        break
                break
        if counter_up_series == 1 and not na(up_list[0])
            in_the_range_up := true
        counter_up_series := 0
        if built_bricks_up < required_bricks_up
            r_open += box_size
            r_close := r_open + box_size
            built_bricks_up += 1

        else if in_the_range_up and built_bricks_up == required_bricks_up
            r_close := na
        else
            up_stop_index := up_temporary_index
            built_bricks_up := 0
            built_bricks_down := 1
            b_up_move := false
            b_down_move := true
            r_close := r_open - box_size

        in_the_range_up := false
    else if b_down_move
        for i = 0 to bar_index - down_stop_index - 1 by 1
            if not na(down_list[i]) and na(down_list[i + 1])
                counter_down_series += 1
                required_bricks_down := down_list[i]
            if i == bar_index - down_stop_index - 1
                for j = i to 0 by 1
                    down_temporary_index := bar_index[j]
                    required_bricks_down := down_list[j]
                    if j == 0
                        break
                    if not na(down_list[j]) and na(down_list[j - 1])
                        down_temporary_index := bar_index[j - 1]
                        break
                break
        if counter_down_series == 1 and not na(down_list[0])
            in_the_range_down := true
        counter_down_series := 0
        if built_bricks_down < required_bricks_down
            if up_stop_index == 0 and down_stop_index == 0 and built_bricks_down == 0
                r_open += box_size
                r_close := r_open - box_size
                built_bricks_down += 1
            else
                r_open -= box_size
                r_close := r_open - box_size
                built_bricks_down += 1
        else if in_the_range_down and built_bricks_down == required_bricks_down
            r_close := na
        else
            down_stop_index := down_temporary_index
            built_bricks_down := 0
            built_bricks_up := 1
            b_down_move := false
            b_up_move := true
            r_close := r_open + box_size
        in_the_range_down := false
    else
        r_close := na
    [r_open, r_open > r_close ? r_open : r_close, r_open < r_close ? r_open : r_close, r_close]
[r_open, r_high, r_low, r_close] = get_renko(input.float(defval=200.0, title='Box size', minval=0.00000001))
plotcandle(r_open, r_high, r_low, r_close, color=r_close > r_open ? color.green : color.red)



//BJORGUM

// █▀▀▄ ──▀ █▀▀█ █▀▀█ █▀▀▀ █──█ █▀▄▀█ 
// █▀▀▄ ──█ █──█ █▄▄▀ █─▀█ █──█ █─▀─█ 
// ▀▀▀─ █▄█ ▀▀▀▀ ▀─▀▀ ▀▀▀▀ ─▀▀▀ ▀───▀

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Bjorgum

//@version=5
indicator           ('Bjorgum Key Levels', 'Bj Key Levels', overlay= true, max_boxes_count= 500, max_labels_count= 500, max_lines_count=500)

import              Bjorgum/BjCandlePatterns/2 as bj

// ================================== //
// ------------> Tips <-------------- //
// ================================== //

leftTip         =   "Look left for swing high/low in x number of bars to form pivot. The higher the number, the higher the script looks to the left for the highest/lowest point before drawing pivot"        
rightTip        =   "Look right for swing high/low in x number of bars to form pivot. The higher the number, the higher the script looks to the right for the highest/lowest point before drawing pivot"       
nPivTip         =   "This sets the array size, or the number of pivots to track at a time (x highs, and x number of lows)" 
atrLenTip       =   "Number of bars to average. ATR is used to standardize zone width between assets and timeframes"     
multTip         =   "ATR multiplier to set zone width. Default is half of one ATR from box bottom to box top"     
perTip          =   "Max zone size as a percent of price. Some assets can be too volatile at low prices creating an unreasonably sized zone"
maxTip          =   "Number of boxes for candlestick patterns to track historically. Note: the higher the number the less pivot zones will be tracked when looking back in time due to the limitation on the number of box elements allowed at once"
futTip          =   "Number of bars to offset labels for price levels"
srcTip          =   "Source input for pivots. Default tracks the highest and lowest bodies of HA candles to average price action, which can result in a level that sits in the overlap of support and resistance"     
alignZonesTip   =   "Aligns recurring zones who's edges overlap an existing zone creating a zone that ages in time and intensifies visually"     
extendTip       =   "Extends current zones right"
lLabTip         =   "Show labels for price levels extended off Key Levels"

dhighsTip       =   "Disabling will prevent highs from being tracked"          
dlowsTip        =   "Disabling will prevent lows from being tracked"         
detectBOTip     =   "Show points that price action breaks above all pivots. An arrow from below is displayed"        
detectBDTip     =   "Show points that price action breaks below all pivots. An arrow from above is displayed"         
breakUpTip      =   "Show points that price action breaks above resistance. An arrow from below is displayed"         
breakDnTip      =   "Show points that price action breaks below support. An arrow from above is displayed"          
falseBullTip    =   "Show points that price action initially breaks below support before reversing. False moves can lead to fast moves in the opposite direction (bear trap). A large arrow from below is displayed"          
falseBearTip    =   "Show points that price action initially breaks above resistance before reversing. False moves can lead to fast moves in the opposite direction (bull trap). A large arrow from above is displayed"           
supPushTip      =   "Show up candles that are detected within a support zone. Can show points support is being respected. A triangle from below is displayed"          
resPushTip      =   "Show down candles that are detected within a resistance zone. Can show points resistance is being respected. A triangle from above is displayed"           
curlTip         =   "Show Bjorgum TSI 'curl' when candles are detected in the range of a key zone. Can show momentum shift at key levels. (Correlates to Bjorgum TSI indicator)" 

labelsTip       =   "Show a label for detected candle patterns"
sBoxTip         =   "Show a box around detected candle patterns"
dTip            =   "Detect Doji candle patterns"      
beTip           =   "Detect Engulfing patterns"     
hsTip           =   "Detect Hammers and Shooting Star patterns"     
dgTip           =   "Detect Dragonfly Doji and Gravestone Doji patterns"     
twTip           =   "Detect Tweezer Top and Tweezer Bottom patterns"     
stTip           =   "Detect Spinning Top patterns"     
pcTip           =   "Detect Piercing and Dark Cloud Cover patterns"     
bhTip           =   "Detect Harami candle patterns"     
lsTip           =   "Detect Long Upper Shadow and Long Lower Shadow patterns"     

ecWickTip       =   "Determines if engulfing candles must engulf the wick or just the body of the preceding candle"     
colorMatchTip   =   "Determines if hammers must be up candles and shooting stars must be down candles"     
closeHalfTip    =   "Determines if Tweezer patterns must close beyond the half way point of the preceding candle"     
atrMaxTip       =   "Maximum size of setup candles (as a multiplier of the current ATR)"     
rejectWickTip   =   "The maximum wick size as a percentage of body size allowable for a rejection wick on the resolution candle of the pattern. 0 disables the filter"
hammerFibTip    =   "The relationship of body to candle size for hammers and stars. (ie. body is 33% of total candle size)."     
hsShadowPercTip =   "The maximum allowable opposing wick size as a percent of body size (ex. top wick for a hammer pattern etc.)"     
hammerSizeTip   =   "The minimum size of hammers, stars, or long shadows as a multiplier of ATR. (To filter out tiny setups)"     
dojiSizeTip     =   "The relationship of body to candle size (ie. body is 5% of total candle size)."     
dojiWickSizeTip =   "Maximum wick size comparative to the opposite wick. (eg. 2 = bottom wick must be less than or equal to 2x the top wick)."     
luRatioTip      =   "A relationship of the upper wick to the overall candle size expressed as a percent."     

lookbackTip     =   "Number of candles that can be included in a false break signal"        
swingTip        =   "Swing detection is used to filter signals on breakout type signals. A higher number will mean more significant points, but less of them"        
reflectTip      =   "Filter to ensure a setup is a significant swing point. Look back this far"
offsetTip       =   "Candle pattern high/low distance from absolute swing high/low. Example: 0 would filter patterns that are only the highest/lowest, 1 filters second highest over the significant length, etc."

pivotColorTip   =   "Color of key levels\n(bull color, bear color, transparency of box background, transparency of box borders)"            
breakoutTip     =   "Color of breakout arrows\n(bull, bear, transp., transp.)"           
SnRTip          =   "Color of triangles for broken support or resistance\n(bull, bear, transp., transp.)"   
falseBreakTip   =   "Color of arrows for false breaks\n(bull, bear, transp., transp., arrow max height in pixels)"            
moveTip         =   "Color of triangles for candles that are detected within zones\n(bull, bear, transp., transp.)"    
patTip          =   "Color of boxes that wrap candestick patterns\n(bull, neutral, bear, border transp., bg transp.)"    
labTip          =   "Color of labels that mark candestick patterns\n(bull, neutral, bear, and transp for both text and label bg.)"    
stratTip        =   "TSI speed control presets. Both speeds correlate to the Bjorgum TSI indicator"

// ================================== //
// ---------> User Input <----------- //
// ================================== //

left            =   input.int       (20     ,   "Look Left"                     ,   group= "Zones"                , tooltip= leftTip            )    
right           =   input.int       (15     ,   "Look Right"                    ,   group= "Zones"                , tooltip= rightTip           )    
nPiv            =   input.int       (4      ,   "Number of Pivots"              ,   group= "Zones"                , tooltip= nPivTip            )
atrLen          =   input.int       (30     ,   "ATR Length"                    ,   group= "Zones"                , tooltip= atrLenTip          )
mult            =   input.float     (0.5    ,   "Zone Width (ATR)"              ,   group= "Zones"                , tooltip= multTip            ,   step   = 0.1)
per             =   input.float     (5      ,   "Max Zone Percent"              ,   group= "Zones"                , tooltip= perTip             )
max             =   input.float     (10     ,   "Max Boxes for Patterns"        ,   group= "Zones"                , tooltip= maxTip             )
fut             =   input.int       (30     ,   "Offset For Labels"             ,   group= "Zones"                , tooltip= futTip             )
src             =   input.string    ("HA"   ,   "Source For Pivots"             ,   group= "Zones"                , tooltip= srcTip             ,   options= ["HA", "High/Low Body", "High/Low"])
alignZones      =   input.bool      (true   ,   "Align Zones"                   ,   group= "Zones"                , tooltip= alignZonesTip      )
extend          =   input.bool      (false  ,   "Extend Right"                  ,   group= "Zones"                , tooltip= extendTip          )
lLab            =   input.bool      (false  ,   "Show Level Labels"             ,   group= "Zones"                , tooltip= lLabTip            )

dhighs          =   input.bool      (true   ,   "Detect Pivot Highs"            ,   group= "Detection"            , tooltip= dhighsTip          )
dlows           =   input.bool      (true   ,   "Detect Pivot Lows"             ,   group= "Detection"            , tooltip= dlowsTip           )
detectBO        =   input.bool      (false  ,   "Detect Breakout"               ,   group= "Detection"            , tooltip= detectBOTip        )
detectBD        =   input.bool      (false  ,   "Detect Breakdown"              ,   group= "Detection"            , tooltip= detectBDTip        )
breakUp         =   input.bool      (false  ,   "Detect Resistance Break"       ,   group= "Detection"            , tooltip= breakUpTip         )
breakDn         =   input.bool      (false  ,   "Detect Support Break"          ,   group= "Detection"            , tooltip= breakDnTip         ) 
falseBull       =   input.bool      (false  ,   "Detect False Breakdown"        ,   group= "Detection"            , tooltip= falseBullTip       )
falseBear       =   input.bool      (false  ,   "Detect False Breakup"          ,   group= "Detection"            , tooltip= falseBearTip       ) 
supPush         =   input.bool      (false  ,   "Detect Moves Off Support"      ,   group= "Detection"            , tooltip= supPushTip         )
resPush         =   input.bool      (false  ,   "Detect Moves Off Resistance"   ,   group= "Detection"            , tooltip= resPushTip         ) 
curl            =   input.bool      (false  ,   "Detect TSI Curl"               ,   group= "Detection"            , tooltip= curlTip            ) 

labels          =   input.bool      (false  ,   "Show Label"                    ,   group= "Candle Patterns"      , tooltip= labelsTip          )
sBox            =   input.bool      (false  ,   "Show Boxes Around Patterns"    ,   group= "Candle Patterns"      , tooltip= sBoxTip            )
d_              =   input.bool      (false  ,   "Detect Doji"                   ,   group= "Candle Patterns"      , tooltip= dTip               )
be_             =   input.bool      (false  ,   "Detect Engulfing"              ,   group= "Candle Patterns"      , tooltip= beTip              )
hs_             =   input.bool      (false  ,   "Detect Hammers and Stars"      ,   group= "Candle Patterns"      , tooltip= hsTip              )
dg_             =   input.bool      (false  ,   "Detect Dragons and Graves"     ,   group= "Candle Patterns"      , tooltip= dgTip              )
tw_             =   input.bool      (false  ,   "Detect Tweezers"               ,   group= "Candle Patterns"      , tooltip= twTip              )
st_             =   input.bool      (false  ,   "Detect Spinning Top"           ,   group= "Candle Patterns"      , tooltip= stTip              )
pc_             =   input.bool      (false  ,   "Detect Piercing and Clouds"    ,   group= "Candle Patterns"      , tooltip= pcTip              )
bh_             =   input.bool      (false  ,   "Detect Harami"                 ,   group= "Candle Patterns"      , tooltip= bhTip              )
ls_             =   input.bool      (false  ,   "Detect Long Shadows"           ,   group= "Candle Patterns"      , tooltip= lsTip              )

alertMode       =   input.string    (alert.freq_once_per_bar_close              ,   "Alerts Mode"                 , group  = "Alert Frequency"  ,   options= [alert.freq_once_per_bar, alert.freq_once_per_bar_close]) 

ecWick          =   input.bool      (false  ,   "Engulfing Must Engulf Wick"    ,   group= "Candle Filters"       , tooltip= ecWickTip          )
colorMatch      =   input.bool      (false  ,   "H&S Must Match Color"          ,   group= "Candle Filters"       , tooltip= colorMatchTip      )
closeHalf       =   input.bool      (false  ,   "Tweezer Close Over Half"       ,   group= "Candle Filters"       , tooltip= closeHalfTip       )
atrMax          =   input.float     (0.0    ,   "Max Candle Size (× ATR)"       ,   group= "Candle Filters"       , tooltip= atrMaxTip          ,   step= 0.1 )
rejectWickMax   =   input.float     (0.0    ,   "[EC] Max Reject Wick Size"     ,   group= "Candle Filters"       , tooltip= rejectWickTip      ,   step= 1   )  
hammerFib       =   input.float     (33     ,   "[HS] H&S Ratio (%)"            ,   group= "Candle Filters"       , tooltip= hammerFibTip       ,   step= 1   ) 
hsShadowPerc    =   input.float     (5      ,   "[HS] H&S Opposing Shadow (%)"  ,   group= "Candle Filters"       , tooltip= hsShadowPercTip    ,   step= 1   ) 
hammerSize      =   input.float     (0.1    ,   "[HS] H&S Min Size (× ATR)"     ,   group= "Candle Filters"       , tooltip= hammerSizeTip      ,   step= 0.1 ) 
dojiSize        =   input.float     (5      ,   "[DJ] Doji Size (%)"            ,   group= "Candle Filters"       , tooltip= dojiSizeTip        ,   step= 1   )
dojiWickSize    =   input.float     (2      ,   "[DJ] Max Doji Wick Size"       ,   group= "Candle Filters"       , tooltip= dojiWickSizeTip    ,   step= 1   )
luRatio         =   input.float     (75     ,   "[LS] Long Shadow (%)"          ,   group= "Candle Filters"       , tooltip= luRatioTip         ,   step= 1   ) 

lookback        =   input.int       (2      ,   "Lookback For Breaks"           ,   group= "Lookback"             , tooltip= lookbackTip        )
swing           =   input.int       (5      ,   "swing High/Low"                ,   group= "Lookback"             , tooltip= swingTip           )
reflect         =   input.int       (10     ,   "Significant High/Low"          ,   group= "Lookback"             , tooltip= reflectTip         )
offset          =   input.int       (1      ,   "Consider Bar From High/Low"    ,   group= "Lookback"             , tooltip= offsetTip          )

bullCol         =   input.color     (#64b5f6,   ""   ,  inline= "1"             ,   group= "Pivot Color"                                        )
bearCol         =   input.color     (#ffeb3b,   ""   ,  inline= "1"             ,   group= "Pivot Color"                                        )
bgTransp        =   input.int       (95     ,   ""   ,  inline= "1"             ,   group= "Pivot Color"                                        )   
bordTransp      =   input.int       (60     ,   ""   ,  inline= "1"             ,   group= "Pivot Color"          , tooltip= pivotColorTip      )

bullBreak       =   input.color     (#ff6d00,   ""   ,  inline= "2"             ,   group= "Breakout Color"                                     )
bearBreak       =   input.color     (#ff00ff,   ""   ,  inline= "2"             ,   group= "Breakout Color"                                     )
bullTransp      =   input.int       (25     ,   ""   ,  inline= "2"             ,   group= "Breakout Color"                                     )   
bearTransp      =   input.int       (25     ,   ""   ,  inline= "2"             ,   group= "Breakout Color"       , tooltip= breakoutTip        ) 

resBreakCol     =   input.color     (#17ff00,   ""   ,  inline= "3"             ,   group= "S&R Break Color"                                    )
supBreakCol     =   input.color     (#ff0000,   ""   ,  inline= "3"             ,   group= "S&R Break Color"                                    )
resBreakTransp  =   input.int       (25     ,   ""   ,  inline= "3"             ,   group= "S&R Break Color"                                    )   
supBreakTransp  =   input.int       (25     ,   ""   ,  inline= "3"             ,   group= "S&R Break Color"      , tooltip= SnRTip             ) 

falseBullCol    =   input.color     (#17ff00,   ""   ,  inline= "4"             ,   group= "False Break Color"                                  )
falseBearCol    =   input.color     (#ff0000,   ""   ,  inline= "4"             ,   group= "False Break Color"                                  )
falseBullTransp =   input.int       (25     ,   ""   ,  inline= "4"             ,   group= "False Break Color"                                  )   
falseBearTransp =   input.int       (25     ,   ""   ,  inline= "4"             ,   group= "False Break Color"                                  ) 
arrowMax        =   input.int       (75     ,   ""   ,  inline= "4"             ,   group= "False Break Color"    , tooltip= falseBreakTip      ) 

moveBull        =   input.color     (#64b5f6,   ""   ,  inline= "5"             ,   group= "Moves From S&R Color"                               )
moveBear        =   input.color     (#ffeb3b,   ""   ,  inline= "5"             ,   group= "Moves From S&R Color"                               )
moveBullTransp  =   input.int       (25     ,   ""   ,  inline= "5"             ,   group= "Moves From S&R Color"                               )   
moveBearTransp  =   input.int       (25     ,   ""   ,  inline= "5"             ,   group= "Moves From S&R Color" , tooltip= moveTip            ) 

curlBull        =   input.color     (#17ff00,   ""   ,  inline= "6"             ,   group= "Momentum Curl Color"                                )
curlBear        =   input.color     (#f3ff00,   ""   ,  inline= "6"             ,   group= "Momentum Curl Color"                                )
curlBullTransp  =   input.int       (40     ,   ""   ,  inline= "6"             ,   group= "Momentum Curl Color"                                )   
curlBearTransp  =   input.int       (40     ,   ""   ,  inline= "6"             ,   group= "Momentum Curl Color"  , tooltip= curlTip            ) 

patBull         =   input.color     (#17ff00,   ""   ,  inline= "7"             ,   group= "Pattern Box Color"                                  )
patNeut         =   input.color     (#b2b5be,   ""   ,  inline= "7"             ,   group= "Pattern Box Color"                                  )
patBear         =   input.color     (#ff0000,   ""   ,  inline= "7"             ,   group= "Pattern Box Color"                                  )
patBoTransp     =   input.int       (80     ,   ""   ,  inline= "7"             ,   group= "Pattern Box Color"                                  )   
patBgTransp     =   input.int       (90     ,   ""   ,  inline= "7"             ,   group= "Pattern Box Color"    , tooltip= patTip             ) 

textBull        =   input.color     (#17ff00,   ""   ,  inline= "9"             ,   group= "Label Color (Text/Bg)"                              )
textNeut        =   input.color     (#b2b5be,   ""   ,  inline= "9"             ,   group= "Label Color (Text/Bg)"                              )
textBear        =   input.color     (#ff0000,   ""   ,  inline= "9"             ,   group= "Label Color (Text/Bg)"                              )
textTransp      =   input.int       (0      ,   ""   ,  inline= "9"             ,   group= "Label Color (Text/Bg)"                              )                                  

labBull         =   input.color     (#17ff00,   ""   ,  inline= "10"            ,   group= "Label Color (Text/Bg)"                              )
labNeut         =   input.color     (#b2b5be,   ""   ,  inline= "10"            ,   group= "Label Color (Text/Bg)"                              )
labBear         =   input.color     (#ff0000,   ""   ,  inline= "10"            ,   group= "Label Color (Text/Bg)"                              )
labTransp       =   input.int       (80     ,   ""   ,  inline= "10"            ,   group= "Label Color (Text/Bg)", tooltip= labTip             )                                  

strat           =   input.string    ("Fast" ,   "Select a Speed"                ,   group= "TSI Speed Control"    , tooltip= stratTip           ,   options= ["Fast", "Slow"])
    
longf           =   input.int       (25     ,   "Long Length"                   ,   group= "TSI Fast Settings"                                  )
shortf          =   input.int       (5      ,   "Short Length"                  ,   group= "TSI Fast Settings"                                  )
signalf         =   input.int       (14     ,   "Signal Length"                 ,   group= "TSI Fast Settings"                                  )

longs           =   input.int       (25     ,   "Long Length"                   ,   group= "TSI Slow Settings"                                  )
shorts          =   input.int       (13     ,   "Short Length"                  ,   group= "TSI Slow Settings"                                  )
signals         =   input.int       (13     ,   "Signal Length"                 ,   group= "TSI Slow Settings"                                  )

// ================================== //
// -----> Immutable Constants <------ //
// ================================== //    
 
sync            =   bar_index
labUp           =   label.style_label_up
labDn           =   label.style_label_down
confirmed       =   barstate.isconfirmed
extrap          =   extend ?        extend.right  : extend.none

var pivotHigh   =   array.new_box   (nPiv)
var pivotLows   =   array.new_box   (nPiv)  
var highBull    =   array.new_bool  (nPiv)
var lowsBull    =   array.new_bool  (nPiv)
var boxes       =   array.new_box   ()
var bullBorder  =   color.new       (bullCol      , bordTransp      )
var bullBgCol   =   color.new       (bullCol      , bgTransp        )
var bearBorder  =   color.new       (bearCol      , bordTransp      )
var bearBgCol   =   color.new       (bearCol      , bgTransp        )
var upCol       =   color.new       (bullBreak    , bullTransp      )
var dnCol       =   color.new       (bearBreak    , bearTransp      )
var supCol      =   color.new       (resBreakCol  , resBreakTransp  )
var resCol      =   color.new       (supBreakCol  , supBreakTransp  )
var fBull       =   color.new       (falseBullCol , falseBullTransp )
var fBear       =   color.new       (falseBearCol , falseBearTransp )
var moveBullCol =   color.new       (moveBull     , moveBullTransp  )
var moveBearCol =   color.new       (moveBear     , moveBearTransp  )
var curlBullCol =   color.new       (curlBull     , curlBullTransp  )
var curlBearCol =   color.new       (curlBear     , curlBearTransp  )
var patBullBg   =   color.new       (patBull      , patBgTransp     )
var patNeutBg   =   color.new       (patNeut      , patBgTransp     )
var patBearBg   =   color.new       (patBear      , patBgTransp     )
var patBullBo   =   color.new       (patBull      , patBoTransp     )
var patNeutBo   =   color.new       (patNeut      , patBoTransp     )
var patBearBo   =   color.new       (patBear      , patBoTransp     )
var textBullCol =   color.new       (textBull     , textTransp      )
var textNeutCol =   color.new       (textNeut     , textTransp      )
var textBearCol =   color.new       (textBear     , textTransp      )
var labBullCol  =   color.new       (labBull      , labTransp       )
var labNeutCol  =   color.new       (labNeut      , labTransp       )
var labBearCol  =   color.new       (labBear      , labTransp       )

haSrc           =   src    ==       "HA"    
hiLoSrc         =   src    ==       "High/Low"
tsifast         =   strat  ==       "Fast"
tsislow         =   strat  ==       "Slow"

// ================================== //
// ---> Functional Declarations <---- //
// ================================== //

atr             =   ta.atr          (atrLen)
perMax          =   close*          0.02
min             =   math.min        (perMax, atr*0.3)

_haBody()       =>
    haClose     =   (open + high  +  low  + close)    / 4
    haOpen      =   float(na)
    haOpen      :=  na(haOpen[1]) ? (open + close)    / 2 : 
                   (nz(haOpen[1]) + nz(haClose[1]))   / 2
    
    [haOpen, haClose]
    
_extend(_x) =>
    for i = 0 to               array.size       (_x)-1
        box.set_right          (array.get       (_x, i), sync)
        
_arrayLoad(_x, _max, _val) =>  
    array.unshift                               (_x,   _val)   
    if  array.size                              (_x) > _max
        array.pop                               (_x)

_arrayBox(_x, _max, _val) =>  
    array.unshift                               (_x,   _val)   
    if       array.size                         (_x) > _max
        _b = array.pop                          (_x)
        if extend
            box.set_extend                      (_b, extend.none)

_arrayWrap(_x, _max, _val) =>  
    array.unshift                               (_x,   _val)   
    if  array.size                              (_x) > _max
        box.delete(array.pop                    (_x))

_delLab(_x)     =>
    if array.size(_x) > 0 
        label.delete           (array.pop       (_x))

_delLine(_x)    =>
    if array.size(_x) > 0 
        line.delete            (array.pop       (_x))

_delLevels(_x, _y)  =>
    for i = 0 to array.size                     (_x)-1
        _delLab                                 (_x)
        _delLine                                (_y)

_box(_x1, _t, _r, _b, _boCol, _bgCol, _e) =>
    box.new(                   _x1, _t, _r, _b  , 
     xloc        =             xloc.bar_index   ,
     extend      =             _e               ,
     border_color=             _boCol           ,   
     bgcolor     =             _bgCol           ) 

_wrap(_cond, _x, _bb, _bc, _bgc) =>
    _t           =             ta.highest       (high, _bb) + min
    _b           =             ta.lowest        (low , _bb) - min
    _l           =             bar_index -      _bb
    _r           =             bar_index +      1
    if  _cond
        _arrayWrap            (_x, max, _box    (_l, _t, _r, _b, _bc, _bgc, extend.none)) 

_getBox(_x,_i)   =>
    _box         =             array.get        (_x,_i)
    _t           =             box.get_top      (_box)
    _b           =             box.get_bottom   (_box)
    [_t, _b]
    
_align(_x,_y)    =>
    for i = 0 to               array.size       (_x) -1
        [_T, _B] =             _getBox          (_y, 0)
        [_t, _b] =             _getBox          (_x, i)
        if _T > _b and         _T < _t or 
           _B < _t and         _B > _b or 
           _T > _t and         _B < _b or 
           _B > _b and         _T < _t
            box.set_top        (array.get       (_y, 0), _t)
            box.set_bottom     (array.get       (_y, 0), _b)
 
_color(_x, _y)     =>
    var int _track = nPiv
    for i = 0 to               array.size       (_x) -1
        [t_, b_] =             _getBox          (_x, i)
        _isBull  =             array.get        (_y, i)
        if close > t_ and not  _isBull
            box.set_extend(    array.get        (_x, i), extend.none)
            array.set(_x, i,   _box             (sync  , t_, sync, b_, bullBorder, bullBgCol, extrap))
            array.set(_y, i,   true)
            _track += 1
        if close < b_ and _isBull
            box.set_extend(    array.get        (_x, i), extend.none)
            array.set(_x, i,   _box             (sync  , t_, sync, b_, bearBorder, bearBgCol, extrap))
            array.set(_y, i,   false)
            _track -= 1
    _track

_detect(_x,_y)      =>
    int  _i         = 0
    bool _found     = false
    bool _isBull    = na
    while (not _found and _i < array.size       (_x)  )
        [t_, b_] =             _getBox          (_x,_i)
        if low < t_ and high > b_
            _isBull :=         array.get        (_y,_i)
            _found  :=         true
        _i          +=         1
    [_found, _isBull]

_falseBreak(_l)     =>       
    bool _d         = false
    bool _u         = false
    for i = 1 to lookback
        if _l[i] < _l and _l[i+1] >= _l and _l[1] < _l 
            _d      := true
        if _l[i] > _l and _l[i+1] <= _l and _l[1] > _l 
            _u      := true
    [_d, _u]

_numLevel(_x,_y)    =>
    int _above      = 0
    int _fill       = 0
    for i = 0 to               array.size       (_x)-1
        _isBull     =          array.get        (_x,i)
        if  _isBull
            _above += 1
        if  not na(_isBull)
            _fill  += 1
    for i = 0 to               array.size       (_y)-1
        _isBull     =          array.get        (_y,i)
        if  _isBull
            _above += 1
        if  not na(_isBull)
            _fill  += 1
    [_above, _fill]  

_check(_src,_l)     =>
    bool _check     = false
    for i = 0 to _l
        if _src[i]
            _check := true
    _check

_count(_src, _l)    =>
    int _result     = 0
    for i = 0 to _l
        if _src > _src[i]
            _result += 1
    _result

_label(_x, _y, y, _s, _col) =>
    transp = math.min   (bordTransp, bgTransp)
    array.unshift       (_x,   label.new (sync+fut,   y                                        , 
                                          text      = str.tostring(math.round_to_mintick(y)   ), 
                                          color     = color.new(_col,transp)                   , 
                                          style     = _s                                       , 
                                          textcolor = color.white                             ))
    if not extend and fut > 0
        array.unshift   (_y,   line.new  (sync, y, sync+fut, y, color= color.new(_col, transp)))

_level(_x, _y)          =>
    var label [] lab    =      array.new_label  (nPiv)
    var line  [] lines  =      array.new_line   (nPiv)
    if barstate.islast and lLab
        _delLevels             (lab, lines)
        for i = 0 to           array.size       (_x)-1
            [_t, _b]    =      _getBox          (_x,i)
            _isBull     =      array.get        (_y,i)
            _col        =      _isBull ?        bullCol : bearCol
            if close >  _t 
                _label  (lab, lines, _t, labUp, _col)
            if close <  _b 
                _label  (lab, lines, _b, labDn, _col)
            if close <  _t and close >   _b
                _label  (lab, lines, _t, labDn, _col)
                _label  (lab, lines, _b, labUp, _col)

_alert(_x, _y) =>
    if _x
        alert   (_y + timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)
        
// ================================== //
// ----> Variable Calculations <----- //
// ================================== //

shortvar        =   tsifast ?           shortf  :       shorts   
longvar         =   tsifast ?           longf   :       longs    
signalvar       =   tsifast ?           signalf :       signals 

tsi             =   ta.tsi              (close,         shortvar,   longvar)
tsl             =   ta.ema              (tsi,           signalvar)

highest         =   close ==            ta.highest      (close,     right)
lowest          =   close ==            ta.lowest       (close,     right)

closeLows       =   ta.lowest           (close,         swing)
closeHigh       =   ta.highest          (close,         swing)

numLows         =   _count              (low,           reflect)
numHigh         =   _count              (high,          reflect)

[open_, close_] =   _haBody             ()

hiHaBod         =   math.max            (close_,        open_)
loHaBod         =   math.min            (close_,        open_)

hiBod           =   math.max            (close,         open)
loBod           =   math.min            (close,         open)

srcHigh         =   haSrc ?             hiHaBod :       hiLoSrc ?   high :      hiBod
srcLow          =   haSrc ?             loHaBod :       hiLoSrc ?   low  :      loBod

pivot_high      =   ta.pivothigh        (srcHigh,       left,       right)
pivot_low       =   ta.pivotlow         (srcLow,        left,       right)

perc            =   close*              (per/100)

band            =   math.min            (atr*mult,      perc)       [right]     /2

HH              =   pivot_high+         band
HL              =   pivot_high-         band

LH              =   pivot_low+          band
LL              =   pivot_low-          band

coDiff          =   close -             open

// ================================== //
// --------> Logical Order <--------- //
// ================================== //

if pivot_high and   dhighs and  confirmed
    _arrayLoad      (highBull , nPiv,   false)      
    _arrayBox       (pivotHigh, nPiv,   _box(sync[right], HH, sync, HL, bearBorder, bearBgCol, extrap))

if pivot_low  and   dlows and   confirmed
    _arrayLoad      (lowsBull , nPiv,   true)      
    _arrayBox       (pivotLows, nPiv,   _box(sync[right], LH, sync, LL, bullBorder, bullBgCol, extrap))

if alignZones
    _align          (pivotHigh,         pivotHigh)
    _align          (pivotHigh,         pivotLows)    
    _align          (pivotLows,         pivotLows)
    _align          (pivotLows,         pivotHigh)

_extend             (pivotHigh)
_extend             (pivotLows)

trackHigh       =   _color              (pivotHigh,     highBull)
trackLows       =   _color              (pivotLows,     lowsBull)

// ================================== //
// ----> Conditional Parameters <---- //
// ================================== //

isLows          =   closeLows      ==   close
isHigh          =   closeHigh      ==   close

wasLows         =   _check              (isLows,        lookback)
wasHigh         =   _check              (isHigh,        lookback)

[above, total]  =   _numLevel           (highBull,      lowsBull)

moveAbove       =   trackHigh       >   trackHigh[1]
moveBelow       =   trackLows       <   trackLows[1]

resBreak        =   (trackLows      >   trackLows[1]    or  moveAbove) 
supBreak        =   (trackHigh      <   trackHigh[1]    or  moveBelow) 

breakOut        =   moveAbove     and   highest and     above == total             
breakDwn        =   moveBelow     and   lowest  and     above == 0         

[dh, uh]        =   _falseBreak         (trackHigh) 
[dl, ul]        =   _falseBreak         (trackLows) 

falseBreakBull  =   wasLows       and   (dh or dl)
falseBreakBear  =   wasHigh       and   (uh or ul)

[fh,hb]         =   _detect             (pivotHigh,     highBull)
[fl,lb]         =   _detect             (pivotLows,     lowsBull)

bull            =   (fh or fl) and      (hb or lb)
bear            =   (fh or fl) and not  (hb or lb)

bullCheck       =   not resBreak  and   not resBreak[1] and (fh or fl) and  close > open and     (hb or lb)
bearCheck       =   not supBreak  and   not supBreak[1] and (fh or fl) and  close < open and not (hb or lb)

highrange       =   reflect-offset
lowsrange       =   offset

sigLows         =   numLows        <=   lowsrange  
sigHigh         =   numHigh        >=   highrange 

isBull1         =   sigLows       and   bull
isBear1         =   sigHigh       and   bear 

isBull2         =   (sigLows       or   sigLows[1]) and         (bull or bull[1])
isBear2         =   (sigHigh       or   sigHigh[1]) and         (bear or bear[1])

data            =   tsi > tsi[1]  and   tsi < tsl 
dtat            =   tsi < tsi[1]  and   tsi > tsl 

hMatch          =   not colorMatch or   close > open
sMatch          =   not colorMatch or   close < open

hsFilter        =   bj.barRange()  >=   hammerSize * atr
atrMaxSize      =   bj.barRange()  <=   atrMax     * atr or     atrMax == 0.0

// ================================== //
// -----> Pattern Recognition <------ //
// ================================== //

dw              =   isBull1 and d_  and atrMaxSize and bj.doji              (dojiSize           = dojiSize,         dojiWickSize    = dojiWickSize)
db              =   isBear1 and d_  and atrMaxSize and bj.doji              (dojiSize           = dojiSize,         dojiWickSize    = dojiWickSize)
bew             =   isBull2 and be_ and atrMaxSize and bj.bullEngulf        (maxRejectWick      = rejectWickMax,    mustEngulfWick  = ecWick) 
beb             =   isBear2 and be_ and atrMaxSize and bj.bearEngulf        (maxRejectWick      = rejectWickMax,    mustEngulfWick  = ecWick)
h               =   isBull1 and hs_ and atrMaxSize and bj.hammer            (ratio              = hammerFib,        shadowPercent   = hsShadowPerc) and hsFilter and hMatch
ss              =   isBear1 and hs_ and atrMaxSize and bj.star              (ratio              = hammerFib,        shadowPercent   = hsShadowPerc) and hsFilter and sMatch
dd              =   isBull1 and dg_ and atrMaxSize and bj.dragonflyDoji     ()
gd              =   isBear1 and dg_ and atrMaxSize and bj.gravestoneDoji    ()
tb              =   isBull2 and tw_ and atrMaxSize and bj.tweezerBottom     (closeUpperHalf     = closeHalf)
tt              =   isBear2 and tw_ and atrMaxSize and bj.tweezerTop        (closeLowerHalf     = closeHalf)
stw             =   isBull1 and st_ and atrMaxSize and bj.spinningTop       ()
stb             =   isBear1 and st_ and atrMaxSize and bj.spinningTop       ()
p               =   isBull1 and pc_ and atrMaxSize and bj.piercing          ()
dcc             =   isBear1 and pc_ and atrMaxSize and bj.darkCloudCover    ()
bhw             =   isBull1 and bh_ and atrMaxSize and bj.haramiBull        ()  
bhb             =   isBear1 and bh_ and atrMaxSize and bj.haramiBear        ()
ll              =   isBull1 and ls_ and atrMaxSize and bj.lls               (ratio              = luRatio)          and hsFilter
lu              =   isBear1 and ls_ and atrMaxSize and bj.lus               (ratio              = luRatio)          and hsFilter

// ================================== //
// ------> Graphical Display <------- //
// ================================== //

plotFalseDn     =   falseBull     and   falseBreakBull
plotFalseUp     =   falseBear     and   falseBreakBear

falseUpCol      =   plotFalseUp     ?   upCol       :   na
falseDnCol      =   plotFalseDn     ?   dnCol       :   na

plotBreakOut    =   breakOut      and   detectBO    and not     plotFalseDn
plotBreakDn     =   breakDwn      and   detectBD    and not     plotFalseUp

plotResBreak    =   resBreak      and   breakUp     and not     (plotBreakOut or plotFalseDn)
plotSupBreak    =   supBreak      and   breakDn     and not     (plotBreakDn  or plotFalseUp)

plotBullCheck   =   bullCheck     and   supPush
plotBearCheck   =   bearCheck     and   resPush

plotCurlBull    =   curl and data and   bull
plotCurlBear    =   curl and dtat and   bear

plotarrow           (plotFalseUp    ?   coDiff      :   na      ,   colorup  = fBull          ,     colordown=      fBear ,         maxheight=      arrowMax)
plotarrow           (plotFalseDn    ?   coDiff      :   na      ,   colorup  = fBull          ,     colordown=      fBear ,         maxheight=      arrowMax)

plotshape           (plotBreakOut   ,   style=shape.arrowup     ,   location=location.belowbar,     color=          upCol ,         size=           size.small)
plotshape           (plotBreakDn    ,   style=shape.arrowdown   ,   location=location.abovebar,     color=          dnCol ,         size=           size.small)

plotshape           (plotResBreak   ,   style=shape.arrowup     ,   location=location.belowbar,     color=          supCol,         size=           size.small)
plotshape           (plotSupBreak   ,   style=shape.arrowdown   ,   location=location.abovebar,     color=          resCol,         size=           size.small)

plotshape           (plotBullCheck  ,   style=shape.triangleup  ,   location=location.belowbar,     color=          moveBullCol)
plotshape           (plotBearCheck  ,   style=shape.triangledown,   location=location.abovebar,     color=          moveBearCol)

plotshape           (plotCurlBull   ,   style=shape.triangleup  ,   location=location.belowbar,     color=          curlBullCol)
plotshape           (plotCurlBear   ,   style=shape.triangledown,   location=location.abovebar,     color=          curlBearCol)

bj.dLab             (dw  and labels, labNeutCol, textNeutCol), _wrap (dw  and sBox, boxes, 1, patNeutBo, patNeutBg)
bj.bewLab           (bew and labels, labBullCol, textBullCol), _wrap (bew and sBox, boxes, 2, patBullBo, patBullBg)
bj.hLab             (h   and labels, labBullCol, textBullCol), _wrap (h   and sBox, boxes, 1, patBullBo, patBullBg)
bj.ddLab            (dd  and labels, labBullCol, textBullCol), _wrap (dd  and sBox, boxes, 1, patBullBo, patBullBg)
bj.tbLab            (tb  and labels, labBullCol, textBullCol), _wrap (tb  and sBox, boxes, 2, patBullBo, patBullBg)
bj.stwLab           (stw and labels, labNeutCol, textNeutCol), _wrap (stw and sBox, boxes, 1, patBullBo, patNeutBg)
bj.pLab             (p   and labels, labBullCol, textBullCol), _wrap (p   and sBox, boxes, 2, patBullBo, patBullBg)
bj.hwLab            (bhw and labels, labBullCol, textBullCol), _wrap (bhw and sBox, boxes, 2, patBullBo, patBullBg)
bj.llsLab           (ll  and labels, labBullCol, textBullCol), _wrap (ll  and sBox, boxes, 1, patBullBo, patBullBg)

bj.dLab             (db  and labels, labNeutCol, textNeutCol), _wrap (db  and sBox, boxes, 1, patNeutBo, patNeutBg)
bj.bebLab           (beb and labels, labBearCol, textBearCol), _wrap (beb and sBox, boxes, 2, patBearBo, patBearBg)
bj.ssLab            (ss  and labels, labBearCol, textBearCol), _wrap (ss  and sBox, boxes, 1, patBearBo, patBearBg)
bj.gdLab            (gd  and labels, labBearCol, textBearCol), _wrap (gd  and sBox, boxes, 1, patBearBo, patBearBg)
bj.ttLab            (tt  and labels, labBearCol, textBearCol), _wrap (tt  and sBox, boxes, 2, patBearBo, patBearBg)
bj.stbLab           (stb and labels, labNeutCol, textNeutCol), _wrap (stb and sBox, boxes, 1, patBearBo, patBearBg)
bj.dccLab           (dcc and labels, labBearCol, textBearCol), _wrap (dcc and sBox, boxes, 2, patBearBo, patBearBg)
bj.hbLab            (bhb and labels, labBearCol, textBearCol), _wrap (bhb and sBox, boxes, 2, patBearBo, patBearBg)
bj.lusLab           (lu  and labels, labBearCol, textBearCol), _wrap (lu  and sBox, boxes, 1, patBearBo, patBearBg)

_level              (pivotHigh, highBull)
_level              (pivotLows, lowsBull)

// ================================== //
// -----> Alert Functionality <------ //
// ================================== //

alertcondition      (resBreak       ,   'Resistance break'                      ,   'Resistance broke on {{interval}} chart. Price is {{close}}'                    )
alertcondition      (supBreak       ,   'Support break'                         ,   'Support broke on {{interval}} chart. Price is {{close}}'                       )
alertcondition      (bullCheck      ,   'Found support'                         ,   'Pushing Off Key Level Support on {{interval}} chart. Price is {{close}}'       )
alertcondition      (bearCheck      ,   'Found resistance'                      ,   'Pushing Off Key Level Resistance on {{interval}} chart. Price is {{close}}'    )
alertcondition      (falseBreakBull ,   'False break down'                      ,   'False Break Down on {{interval}} chart. Price is {{close}}'                    )
alertcondition      (falseBreakBear ,   'False break up'                        ,   'False Break Up on {{interval}} chart. Price is {{close}}'                      )
alertcondition      (breakOut       ,   'Breakout'                              ,   'Breakout on {{interval}} chart. Price is {{close}}'                            )
alertcondition      (breakDwn       ,   'Breakdown'                             ,   'Breakdown on {{interval}} chart. Price is {{close}}'                           )

_alert              (plotResBreak   ,   'Resistance broke on '                  )
_alert              (plotSupBreak   ,   'Support break '                        )
_alert              (plotBullCheck  ,   'Pushing off key level support on '     )
_alert              (plotBearCheck  ,   'Pushing off key level resistance on '  )
_alert              (plotFalseDn    ,   'False break down on '                  )
_alert              (plotFalseUp    ,   'False break up on '                    )
_alert              (plotBreakOut   ,   'Breakout on '                          )
_alert              (plotBreakDn    ,   'Breakdown on '                         )

_alert              (dw             ,   'Doji at support on '                   )
_alert              (db             ,   'Doji at resistance on '                )
_alert              (bew            ,   'Bullish Engulfing on '                 )
_alert              (beb            ,   'Bearish Engulfing on '                 )
_alert              (h              ,   'Hammer candle on '                     )
_alert              (ss             ,   'Shooting star on '                     )
_alert              (dd             ,   'Dragonfly Doji on '                    )
_alert              (gd             ,   'Gravestone Doji on '                   )
_alert              (tb             ,   'Tweezer Bottom on '                    )
_alert              (tt             ,   'Tweezer Top on '                       )
_alert              (stw            ,   'White Spinning Top on '                )
_alert              (stb            ,   'Black Spinning Top on '                )
_alert              (p              ,   'Piercing on '                          )
_alert              (dcc            ,   'Dark Cloud Cover on '                  )
_alert              (bhw            ,   'Bullish Harami on '                    )
_alert              (bhb            ,   'Bearish Harami on '                    )
_alert              (ll             ,   'Long Lower Shadow on '                 )
_alert              (lu             ,   'Long Upper Shadow on '                 )

//  ____  __ _  ____ 
// (  __)(  ( \(    \
//  ) _) /    / ) D (
// (____)\_)__)(____/


// SQUEEZE MOMENTUM INDICATOR

//
// @author LazyBear 
// List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
//
study(shorttitle = "SQZMOM_LB", title="Squeeze Momentum Indicator [LazyBear]", overlay=false)

length = input(20, title="BB Length")
mult = input(2.0,title="BB MultFactor")
lengthKC=input(20, title="KC Length")
multKC = input(1.5, title="KC MultFactor")

useTrueRange = input(true, title="Use TrueRange (KC)", type=bool)

// Calculate BB
source = close
basis = sma(source, length)
dev = multKC * stdev(source, length)
upperBB = basis + dev
lowerBB = basis - dev

// Calculate KC
ma = sma(source, lengthKC)
range = useTrueRange ? tr : (high - low)
rangema = sma(range, lengthKC)
upperKC = ma + rangema * multKC
lowerKC = ma - rangema * multKC

sqzOn  = (lowerBB > lowerKC) and (upperBB < upperKC)
sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)
noSqz  = (sqzOn == false) and (sqzOff == false)

val = linreg(source  -  avg(avg(highest(high, lengthKC), lowest(low, lengthKC)),sma(close,lengthKC)), 
            lengthKC,0)

bcolor = iff( val > 0, 
            iff( val > nz(val[1]), lime, green),
            iff( val < nz(val[1]), red, maroon))
scolor = noSqz ? blue : sqzOn ? black : gray 
plot(val, color=bcolor, style=histogram, linewidth=4)
plot(0, color=scolor, style=cross, linewidth=2)

// angle of ema 20

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Mango2Juice

//@version=4
study("Angle of Moving Average")

// ————————————————————————————————————————————————————————————
// >>>>>>>>>>>>>>>>>>>>>>>>  Inputs  <<<<<<<<<<<<<<<<<<<<<<<<<<
// ————————————————————————————————————————————————————————————

i_lookback   = input(2,     "Angle Period", input.integer, minval = 1)
i_atrPeriod  = input(10,    "ATR Period",   input.integer, minval = 1)
i_angleLevel = input(6,     "Angle Level",  input.integer, minval = 1)

i_maLength   = input(20,    "MA Length",    input.integer, minval = 1)
i_maType     = input("EMA", "MA Type",      input.string, options=["ALMA", "EMA", "DEMA", "TEMA", "WMA", "VWMA", "SMA", "SMMA", "HMA", "LSMA", "Kijun", "McGinley"])
i_maSource   = input(close, "MA Source",    input.source)

i_lsmaOffset = input(0,   "* Least Squares (LSMA) Only - Offset Value", minval=0)
i_almaOffset = input(0.85,"* Arnaud Legoux (ALMA) Only - Offset Value", minval=0, step=0.01)
i_almaSigma  = input(6,   "* Arnaud Legoux (ALMA) Only - Sigma Value",  minval=0)

i_barColor   = input(false, "Bar Color ?")
i_noTZone    = input(true,  "No Trade Zone")

// ————————————————————————————————————————————————————————————
// >>>>>>>>>>>>>>>>>>>>>>  Functions  <<<<<<<<<<<<<<<<<<<<<<<<<
// ————————————————————————————————————————————————————————————

// ————— Determine Angle by KyJ
f_angle(_src, _lookback, _atrPeriod) =>
    rad2degree = 180 / 3.141592653589793238462643  //pi 
    ang = rad2degree * atan((_src[0] - _src[_lookback]) / atr(_atrPeriod)/_lookback)
    ang

// ————— Moving Averages
f_ma(type, _src, _len) =>
    float result = 0
    if type=="SMA" // Simple
        result := sma(_src, _len)
    if type=="EMA" // Exponential
        result := ema(_src, _len)
    if type=="DEMA" // Double Exponential
        e = ema(_src, _len)
        result := 2 * e - ema(e, _len)
    if type=="TEMA" // Triple Exponential
        e = ema(_src, _len)
        result := 3 * (e - ema(e, _len)) + ema(ema(e, _len), _len)
    if type=="WMA" // Weighted
        result := wma(_src, _len)
    if type=="VWMA" // Volume Weighted
        result := vwma(_src, _len) 
    if type=="SMMA" // Smoothed
        w = wma(_src, _len)
        result := na(w[1]) ? sma(_src, _len) : (w[1] * (_len - 1) + _src) / _len
    if type=="HMA" // Hull
        result := wma(2 * wma(_src, _len / 2) - wma(_src, _len), round(sqrt(_len)))
    if type=="LSMA" // Least Squares
        result := linreg(_src, _len, i_lsmaOffset)
    if type=="ALMA" // Arnaud Legoux
        result := alma(_src, _len, i_almaOffset, i_almaSigma)
    if type=="Kijun" //Kijun-sen
        kijun = avg(lowest(_len), highest(_len))
        result :=kijun
    if type=="McGinley"
        mg = 0.0
        mg := na(mg[1]) ? ema(_src, _len) : mg[1] + (_src - mg[1]) / (_len * pow(_src/mg[1], 4))
        result :=mg
    result
    
_ma    = f_ma(i_maType, i_maSource, i_maLength)
_angle = f_angle(_ma, i_lookback, i_atrPeriod)

// ————————————————————————————————————————————————————————————
// >>>>>>>>>>>>>>>>>>>>>>    Plots    <<<<<<<<<<<<<<<<<<<<<<<<<
// ————————————————————————————————————————————————————————————
color_H = _angle > 0 ? color.lime : _angle < 0 ? color.red : color.gray
color_L = 
   _angle > _angle[1] and (_angle > i_angleLevel or _angle < -i_angleLevel) ? color.lime :
   _angle < _angle[1] and (_angle > i_angleLevel or _angle < -i_angleLevel) ? color.red : color.gray

c_ntz    = i_noTZone ? color_L : color_H
plot(_angle,"Angle MA Line", c_ntz, 3, plot.style_line)
plot(_angle,"Angle MA Histogram", c_ntz, 4, plot.style_histogram)
hline(0)
barcolor(i_barColor ? c_ntz : na)

// >>>>>>>>>>>>>>>>>>>>>>    End of Script    <<<<<<<<<<<<<<<<<<<<<<<<<


// SUPERTREND CUSTOM

//@version=4
study("Supertrend", overlay = true, format=format.price, precision=2, resolution="")

Periods = input(title="ATR Period", type=input.integer, defval=10)
src = input(hl2, title="Source")
Multiplier = input(title="ATR Multiplier", type=input.float, step=0.1, defval=3.0)
changeATR= input(title="Change ATR Calculation Method ?", type=input.bool, defval=true)
showsignals = input(title="Show Buy/Sell Signals ?", type=input.bool, defval=true)
highlighting = input(title="Highlighter On/Off ?", type=input.bool, defval=true)
atr2 = sma(tr, Periods)
atr= changeATR ? atr(Periods) : atr2
up=src-(Multiplier*atr)
up1 = nz(up[1],up)
up := close[1] > up1 ? max(up,up1) : up
dn=src+(Multiplier*atr)
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? min(dn, dn1) : dn
trend = 1
trend := nz(trend[1], trend)
trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend
upPlot = plot(trend == 1 ? up : na, title="Up Trend", style=plot.style_linebr, linewidth=2, color=color.green)
buySignal = trend == 1 and trend[1] == -1
plotshape(buySignal ? up : na, title="UpTrend Begins", location=location.absolute, style=shape.circle, size=size.tiny, color=color.green, transp=0)
plotshape(buySignal and showsignals ? up : na, title="Buy", text="Buy", location=location.absolute, style=shape.labelup, size=size.tiny, color=color.green, textcolor=color.white, transp=0)
dnPlot = plot(trend == 1 ? na : dn, title="Down Trend", style=plot.style_linebr, linewidth=2, color=color.red)
sellSignal = trend == -1 and trend[1] == 1
plotshape(sellSignal ? dn : na, title="DownTrend Begins", location=location.absolute, style=shape.circle, size=size.tiny, color=color.red, transp=0)
plotshape(sellSignal and showsignals ? dn : na, title="Sell", text="Sell", location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white, transp=0)
mPlot = plot(ohlc4, title="", style=plot.style_circles, linewidth=0)
longFillColor = highlighting ? (trend == 1 ? color.green : color.white) : color.white
shortFillColor = highlighting ? (trend == -1 ? color.red : color.white) : color.white
fill(mPlot, upPlot, title="UpTrend Highligter", color=longFillColor)
fill(mPlot, dnPlot, title="DownTrend Highligter", color=shortFillColor)
alertcondition(buySignal, title="SuperTrend Buy", message="SuperTrend Buy!")
alertcondition(sellSignal, title="SuperTrend Sell", message="SuperTrend Sell!")
changeCond = trend != trend[1]
alertcondition(changeCond, title="SuperTrend Direction Change", message="SuperTrend has changed direction!")

//////////
//HALFTREND
//@version=4
// Copyright (c) 2021-present, Alex Orekhov (everget)
study("HalfTrend", overlay=true)

amplitude = input(title="Amplitude", defval=2)
channelDeviation = input(title="Channel Deviation", defval=2)
showArrows = input(title="Show Arrows", defval=true)
showChannels = input(title="Show Channels", defval=true)

var int trend = 0
var int nextTrend = 0
var float maxLowPrice = nz(low[1], low)
var float minHighPrice = nz(high[1], high)

var float up = 0.0
var float down = 0.0
float atrHigh = 0.0
float atrLow = 0.0
float arrowUp = na
float arrowDown = na

atr2 = atr(100) / 2
dev = channelDeviation * atr2

highPrice = high[abs(highestbars(amplitude))]
lowPrice = low[abs(lowestbars(amplitude))]
highma = sma(high, amplitude)
lowma = sma(low, amplitude)

if nextTrend == 1
	maxLowPrice := max(lowPrice, maxLowPrice)

	if highma < maxLowPrice and close < nz(low[1], low)
		trend := 1
		nextTrend := 0
		minHighPrice := highPrice
else
	minHighPrice := min(highPrice, minHighPrice)

	if lowma > minHighPrice and close > nz(high[1], high)
		trend := 0
		nextTrend := 1
		maxLowPrice := lowPrice

if trend == 0
	if not na(trend[1]) and trend[1] != 0
		up := na(down[1]) ? down : down[1]
		arrowUp := up - atr2
	else
		up := na(up[1]) ? maxLowPrice : max(maxLowPrice, up[1])
	atrHigh := up + dev
	atrLow := up - dev
else
	if not na(trend[1]) and trend[1] != 1 
		down := na(up[1]) ? up : up[1]
		arrowDown := down + atr2
	else
		down := na(down[1]) ? minHighPrice : min(minHighPrice, down[1])
	atrHigh := down + dev
	atrLow := down - dev

ht = trend == 0 ? up : down

var color buyColor = color.blue
var color sellColor = color.red

htColor = trend == 0 ? buyColor : sellColor
htPlot = plot(ht, title="HalfTrend", linewidth=2, color=htColor)

atrHighPlot = plot(showChannels ? atrHigh : na, title="ATR High", style=plot.style_circles, color=sellColor)
atrLowPlot = plot(showChannels ? atrLow : na, title="ATR Low", style=plot.style_circles, color=buyColor)

fill(htPlot, atrHighPlot, title="ATR High Ribbon", color=sellColor)
fill(htPlot, atrLowPlot, title="ATR Low Ribbon", color=buyColor)

buySignal = not na(arrowUp) and (trend == 0 and trend[1] == 1)
sellSignal = not na(arrowDown) and (trend == 1 and trend[1] == 0)

plotshape(showArrows and buySignal ? atrLow : na, title="Arrow Up", style=shape.triangleup, location=location.absolute, size=size.tiny, color=buyColor)
plotshape(showArrows and sellSignal ? atrHigh : na, title="Arrow Down", style=shape.triangledown, location=location.absolute, size=size.tiny, color=sellColor)

alertcondition(buySignal, title="Alert: HalfTrend Buy", message="HalfTrend Buy")
alertcondition(sellSignal, title="Alert: HalfTrend Sell", message="HalfTrend Sell")

////////